# -*- coding: utf-8 -*-
"""tensorFlow_L.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w8CuPGQNmbFCJRA69hqGRBMHACMoCEn3
"""

#importando as bibliotecas necessárias

import os
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers, optimizers, datasets
from matplotlib import pyplot as plt
import numpy as np

#criando as funções de treino

(x_train_raw, y_train_raw), (x_test_raw, y_test_raw) = datasets.mnist.load_data()

print(x_train_raw.shape, y_train_raw.shape)
print(x_test_raw.shape, y_test_raw.shape)
print(x_train_raw[0])
print(y_train_raw[0])

#transformando rótulos em variáveis

num_classes = 10
y_train = keras.utils.to_categorical(y_train_raw, num_classes)
y_test = keras.utils.to_categorical(y_test_raw, num_classes)
print(y_train_raw[0])
print(y_train[0])

#visualização do conjunto de dados
plt.figure()
for i in range(9)
    plt.subplot(3, 3, i+1)
    plt.imshow(x_train_raw[i])
    plt.axis('off')
plt.show()

#pré-processamento de dados
#convertendo uma matriz de 28x28 p um vetor de 784 sem perder informações

x_train = x_train_raw.reshape(60000, 784)
x_test = x_test_raw.reshape(10000, 784)

#normalizando valores em pixels
x_train = x_train.astype('float32') / 255
x_test = x_test.astype('float32') / 255

#criando um modelo DNN

model = keras.Sequential([
                          layers.Dense(512, activation='relu', input_dim=784),
                          layers.Dense(256, activation='relu'),
                          layers.Dense(128, activation='relu'),
                          layers.Dense(num_classes, activation='softmax') ])
model.summary()

#compilando o modelo DNN
Optimizer - optimizers.Adam(lr=0.001)
model.compile(loss=keras.losses.categorical_crossentropy,
              optimizer=optimizer, metrics=['accuracy'])

#treinando nosso modelo DNN

history = model.fit(x_train, y_train,
                    batch_size=128, epochs=10 #rodada específica de treinamento,
                    validation_data=(x_test, y_test), verbose=1)

#avaliando o modelo do DNN
score = model.evaluate(x_test, y_test, verbose=0)
print('PERDA DO TESTE:', score[0])
print('ACURÁCIA DO TESTE:', score[1])

#criando a pasta do modelo no caminho relativo
model.save('./model/final_DNN_model.h5') #qnd rodar vai aparecer um aviso

from tensorflow.keras.models import load_model
new_moodel = load_model('./model/final_DNN_model.h5')
new_model.summary()

new_score = new_model.evaluate(x_test, y_test, verbose=0)
print('PERDA DO TESTE:', new_score[0])
print('ACURÁCIA DO TESTE:', new_score[1])

#parte de desafio
#mostrar gráfico do histórico de acurácia do modelo entre as épocas e o gráfico de perdas

#PLOTAR ACURÁCIA
plt.figura(figsize=(12,5))
plt.subplot(1,2,1)
plt.plot(history.history['acurracy'], label='TREINAMENTO')
plt.plot(history.history['val_accuracy'], label='VALIDAÇÃO')
plt.title('ACURÁCIA POR ÉPOCA')
plt.xlabel('ÉPOCAS')
plt.ylabel('ACURÁCIA')
plt.legend()

#PLOTAR A PERDA
plt.subplot(1,2,2)
plt.plot(history.history['loss'], label='TREINAMENTO')
plt.plot(history.history['val_loss'], label='VALIDAÇÃO')
plt.title('PERDA POR ÉPOCA')
plt.xlabel('ÉPOCAS')
plt.ylabel('PERDA')
plt.legend()

plt.tight_layout()
plt.show()

#criar predict e avaliar com a matriz de confusão

import numpy as np
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt

y_pred_prob = model.predict(x_test) #retorna probabilidades

#converter para rótulos preditos
y_pred = np.argmax(y_pred_prob, axis=1)

y_true = np.argmax(y_test, axis=1) #converter p rótulos reais

cm = confusion_matrix(y_true, y_pred) #cria a matriz de confusão

disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot(cmap='Blues')
plt.title('MATRIZ DE CONFUSÃO')
plt.show()

import streamlit as st
import numpy as np
from tensorflow.keras.models import load_model
from PIL import Image, ImageOps

model = load_model("./model/final_DNN_model.h5")

st.title("CLASSIFICADOR DE DÍGITOS MNIST ")
st.write("Envie uma imagem de um dígito (0 a 9) para o modelo reconhecer.")

uploaded_file = st.file_uploader("Envie sua imagem", type=["png", "jpg", "jpeg"])

if uploaded_file is not None:
    image = Image.open(uploaded_file)

    st.image(image, caption="Imagem enviada", width=200)

    # Pré-processamento para MNIST
    image = image.convert("L")
    image = image.resize((28, 28))
    image = ImageOps.invert(image)
    img_array = np.array(image).astype("float32") / 255.0
    img_array = img_array.reshape(1, 784)


    prediction = model.predict(img_array)
    digit = np.argmax(prediction)

    st.subheader(f"DÍGITO PREVISTO: **{digit}**")
    st.write("PROBABILIDADES:")
    st.bar_chart(prediction[0])


#RODANDO O APP.PY NO COMPUTADOR (NN MEXER):
streamlit run app.py & npx localtunnel --port 8501